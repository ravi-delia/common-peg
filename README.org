* Unnamed Common Lisp Peg

UCLP is an experimental implementation of [[https://en.wikipedia.org/wiki/Parsing_expression_grammar][PEG parsing]] in Common Lisp which compiles
grammar rules directly to source code at runtime. A parsing expression grammar is a very
elegent way of recognising, parsing, and transforming text- much more powerful than
regular expressions without the complexity of a custom-built parser. Note that while it is
possible to parse PEGs in guarenteed linear time (at the cost of linear space) with a
packrat parser, UCLP does not. Most patterns unless very poorly written will run in linear
time anyway, and for ease of use some necessary departures from the strict definition are
included.

UCLP patterns are just made of native data structures, so it's easy to compose patterns
and interact with them in code. Unlike regular expressions, PEG syntax is pretty readable
even if you aren't familiar with the specifics. The below example is largely copied from the
[[https://janet-lang.org/docs/peg.html][Janet language documentation]]:

#+BEGIN_SRC lisp
  (defparameter ip-address
    '(grammar
       :dig (range "09")
       :0-4 (range "04")
       :0-5 (range "05")
       :byte (choice
               (sequence "25" :0-5)
               (sequence "2" :0-4 :dig)
               (sequence "1" :dig :dig)
               (between 1 2 :dig))
       :main (sequence :byte "." :byte "." :byte "." :byte)))

  ; uclp:match returns two values, a boolean indicating success/failure and a list of captures
  (uclp:match ip-address "0.0.0.0") ; -> t nil
  (uclp:match ip-address "elephant") ; -> nil
  (uclp:match ip-address "256.0.0.0") ; -> nil
  (uclp:match ip-address "0.0.0.0moretext") ; -> t nil
#+END_SRC

If you follow the link you'll see that the example is almost exactly copied, with
the only differences being those forced by the differences in language syntax. UCLP
is a very close reproduction of the semantics of Janet's PEG module. After experiencing
how pleasant text parsing is in Janet you'll also feel the urge to rewrite it for every
language you use.

As of now UCLP is usable. Bugs are to be expected, but almost all of Janet's patterns are
supported and there shouldn't be any significant footguns. Unfortuantly it has only been
tested on SBCL, but I plan on at least expanding that to some other implementations since
there isn't much implementation-specific code. Except of course that for it to be
performant it needs to be compiled quickly to a quick runtime, ideally machine code.

** Differences From Janet
Mostly UCLP adheres to the behavior of Janet pegs, enough so that Janet's documentation is
better than anything I'll have put together for a little while. However, there are some
differences which obviously need to be documented somewhere. Some are due to differences
in host language, some are due to taste, and some are just features I haven't implemented
yet.

Any difference in behavior from Janet not mentioned below is a *bug*, and either the
behavior or the documentation will need to be changed.

*** Unimplemented
Janet buffers and strings are simply byte strings, and Janet pegs work on arbitrary
strings of bytes. UCLP expects to work with Common Lisp strings, which in general are
/not/ byte strings but vectors of type ~character~. As such the patterns intended to work
on bytes are not implemented. These are: ~uint~, ~uint-be~, ~int~, and ~int-be~. Because
using PEGs to parse binaries is so nice, I plan on at some point implementing some way of
compiling PEGs intended to operate on raw bytes. However, specialization will be at
compile-time and the above patterns will be availible only in a byte PEG.

I'm not yet sure if UCLP will ever support a general ~number~ pattern. It's possible
I'll bring in ~parse-float~ to make a ~float~ as well as a general ~number~ pattern.

The following patterns from Janet are not currently implemented but will be one day:
~column~, ~line~, and ~error~. There will need to be some changes in ~error~ due to the
differences between Janet's error signals and Common Lisp's conditions.

*** Implemented
- While UCLP does not have ~number~, it does have ~integer~, which takes identical
  arguments and parses an integer using ~parse-integer~.
- The pattern ~(sub super-pat sub-pat)~ first matches ~super-pat~, then matches ~sub-pat~
  /within the length/ of whatever ~super-pat~ matched. While matching ~sub-pat~ it is
  exactly as though the input string ends where ~super-pat~ stops. This actually is in
  Janet, but isn't on the documentation page so the difference is noted here.

*** Changes
- Anywhere a string literal can go, including those in ~range~ or ~set~, a character or
  list of characters and strings can also go. This is because Common Lisp strings do not have
  escape codes like Janet strings. So ~(range ("a" #\Newline))~ in UCLP is the same as
  ~(range "a\n")~ in Janet.
- ~between~, ~at-least~, ~at-most~, and ~look~ all have the pattern as the first argument, unlike
  in Janet where it is the last argument.
- ~backmatch~ requires a tag argument, and will not look up captures on the capture stack
- ~replace~ takes either a string which it captures literally, or a function which it calls.
  Taking other datatypes literally will probably be in the next version. But unlike Janet,
  it will never look the matches up.
- Grammars, represented in Janet by tables or structs, are written in UCLP with the
  ~grammar~ rule, which is followed by alternating keywords naming rules and patterns
  implementing them.
- Because the reader doesn't distinguish between ~:s~ and ~:S~, the complement of a built-in
  pattern is prefixed with ~!~. So ~:!s~ instead of ~:S~.
- UCLP includes any (~*~) and some (~+~) varients of complement patterns. So ~:!d+~ is
  ~(some (if-not :d 1))~. See *Aliases* below
  
** Aliases
UCLP offers aliases, keywords that stand in for larger patterns, similar to the Janet's
built-in patterns. And like built-in patterns, aliases are user extensible. However, there
are a number of differences which are important to be aware of. Aliases are not first
class citizens of UCLP- rather than full mutually recursive subpatterns, they are simple
find-and-replace macros, inserted literally. You can reference other aliases from inside
one, but if you create a cycle it'll just blow out the stack. So just be cautious!

Aliases are stored in the alist ~*aliases*~. You can manipulate ~*aliases*~ directly,
or call the helper functions ~register-alias!~ and ~register-alias-suite!~. Both take the
name of the alias as a keyword, and the body as a peg expression, and push the new alias
to ~*aliases*~. However, ~register-alias-suite!~ will also add the complement, some, and
any varients, like so:

#+BEGIN_SRC lisp
  (uclp:register-alias-suite! :v '(set "vV"))
  (uclp:match '(* :v (<- :!v+)) "v not a V") ; => t (" not a ")
#+END_SRC
